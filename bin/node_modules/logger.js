/*
 [Usage]
 var logger = require('./common/logger.js');

 var log = logger.create(); //means output to stderr
 var log = logger.create( 'someDir/someFileName.ext' );
 var log = logger.create({ filePath: 'someDir/someFileName.ext', backupDays: 3 });

 log('msg');
 //now output msg. Sample result: 23:59:59.999 msg\n

 //alternatively, you can use other options(can be combined)
 log('msg', {noNewLine:true}); //means new line char will not be appended.
 log('msg', {head:'myHead'});  //means myHead will be prepended to each line head.
 log('msg', {stderr:true});    //means always copy log to stderr

 [Detail]
 Write log with head format '23:59:59.999 ' to each line head and new line appended.
 Fatal error will be output to stderr (usually means console).

 When use file output, the file will be created when day changes.
 When first output or day changed, it will open/create log file name like someFileName_20131231.ext with append mode,
 and delete any file <= someFileName_20131224.ext.

 Once failed to output to file, it will output to stderr. You can call logger.getLastError() to get info.
 */
'use strict';
var fs = require('fs');
var path = require('path');

var lastError = '';

//log head
var head = '';
//log date and day in month
var date = new Date(0);
var dd = -1;

//log file name suffix pattern
var re_suffixOfLogFileBaseName = /^_[0-9][0-9][0-9][0-9][0-1][0-9][0-3][0-9]$/; //_YYYYMMDD

function makeSuffix(date) { //_YYYYMMDD   //note: must match re_suffixOfLogFileBaseName
  return '_' + date.getFullYear() + dpad2(date.getMonth() + 1) + dpad2(date.getDate());
}

function dpad2(d) {
  return (d < 10) ? '0' + d : d.toString();
}

function dpad3(d) {
  return (d < 10) ? '00' + d : (d < 100) ? '0' + d : d.toString();
}

/*
 * create new log file for today and delete too old backup files
 */
function createNewLogFileForToday(context) {
  //note: when enter here, date, dd means previous day, not today.
  var minDate = new Date(date);
  minDate.setDate(dd - 1 - context.backupDays);
  var minSuffix = makeSuffix(minDate);

  var dir = path.dirname(context.filePath);
  var ext = path.extname(context.filePath);
  var base = path.basename(context.filePath, ext);

  /*
   * delete old log files
   */
  try {
    fs.readdirSync(dir).forEach(function (name) {
      if (path.extname(name) === ext) {
        var _base = path.basename(name, ext);
        if (_base.slice(0, base.length) === base) {
          var _suffix = _base.slice(base.length);
          if (_suffix <= minSuffix && re_suffixOfLogFileBaseName.test(_suffix)) {
            fs.unlinkSync(dir + '/' + name);
          }
        }
      }
    });
  }
  catch (e) {
    if (e.code !== 'ENOENT') {
      lastError = 'Failed to search or delete old log files. ' + e;
      process.stderr.write(head + lastError + '\n');
    }
  }

  /*
   * create new log file for today
   */
  context.todayLogFilePath = dir + '/' + base + makeSuffix(date) + ext;
  try {
    context.fd = fs.openSync(context.todayLogFilePath, 'a'); //use append mode for multi-process
  }
  catch (e) {
    context.err_create = true;
    lastError = 'Failed to open/create file with append mode. ' + e;
    process.stderr.write(head + lastError + '\n');
  }
}//end of createNewLogFileForToday


/**
 * write msg to log file or stderr
 * @param context
 * @param msg (any type)
 * @param option
 *    (
 *      noNewLine: <Boolean> (default: true),
 *      head:      <String>  (default: ''),
 *      stderr:    <Boolean> (default: false)
 *    })
 */
function __log(context, msg, option) {
  var nowMs = Date.now();
  if (nowMs !== date.getTime()) {
    date.setTime(Date.now());

    //make head '23:59:59.999 '
    head = dpad2(date.getHours()) + ':' + dpad2(date.getMinutes()) + ':' + dpad2(date.getSeconds()) + '.' + dpad3(date.getMilliseconds()) + ' ';

    //close current and create new log file if date changed
    if (context.filePath && date.getDate() !== dd) {
      dd = date.getDate();
      __close(context);
      createNewLogFileForToday(context);
    }
  }

  msg = String(msg);
  var actualHead = (option && option.head) ? (head + option.head) : head;

  //remove last new line char
  var origMsgIsEndedWithNewLine = (msg.charCodeAt(msg.length - 1) === 0xa);
  if (origMsgIsEndedWithNewLine) {
    msg = msg.slice(0, -1);
  }

  //prepend head to each line. To disable this, just change to "var s = msg"
  var s = msg.replace(/\n/g, '\n' + actualHead);

  if (option && option.noNewLine === true) {
    if (context.previousLineHaveEnded) {
      s = actualHead + s;
    }
    if (origMsgIsEndedWithNewLine) {
      s += '\n';
    }
    context.isAutoAppendNewLineMode = false;
    context.previousLineHaveEnded = origMsgIsEndedWithNewLine;
  } else {
    if (context.previousLineHaveEnded) {
      s = actualHead + s + '\n';
    } else {
      s = '\n' + actualHead + s + '\n';
    }
    context.isAutoAppendNewLineMode = true;
    context.previousLineHaveEnded = true;
  }

  //write to file if filePath is specified
  var ok = false;
  if (context.fd !== -1) {
    try {
      ok = fs.writeSync(context.fd, s);
    } catch (e) {
      if (!context.err_write) {
        context.err_write = true;
        lastError = 'Failed to append log to file. ' + e;
        process.stderr.write(actualHead + lastError + '\n');
      }
    }
  }

  //write to stderr if failed or no filePath specified
  if (!ok || (option && option.stderr === true)) {
    try {
      process.stderr.write(s);
    } catch (e) {
      lastError = e.message;
    }
  }

  return nowMs;
}

/**
 * create a log context and return a log function which has been bound to the context so can be called directly.
 * @param option option or filePath
 * @returns function log(msg, option {noNewLine:<Boolean>, head:<String>, stderr:<Boolean>}). See __log
 */
function create(option) {
  //create logger context
  var context = {
    fd: -1, //file descriptor
    isAutoAppendNewLineMode: true,
    previousLineHaveEnded: true,
    filePath: null, //null or empty string means output to stderr
    backupDays: 7 //DO NOT set to 0, otherwise it will delete itself when day changed
  };

  if (typeof(option) === 'object') {
    //copy some necessary config
    context.filePath = option.filePath;
    if (option.backupDays >= 1) {
      context.backupDays = option.backupDays;
    }
  }
  else if (typeof(option) === 'string') {
    context.filePath = option;
  }

  //return a log function which has been bound to the context so can be called directly.
  var bound_func = function (msg, option) {
    __log(context, msg, option);
  };

  //save context just for later do release method
  bound_func.context = context;
  return bound_func;
}

function __close(context) {
  if (context.fd !== -1) {
    try {
      fs.closeSync(context.fd);
    } catch (e) {
    }
    context.fd = -1;
    context.err_write = false;
    context.err_create = false;
  }
}

/**
 * close log
 * @param log
 */
function close(log) {
  if (log && log.context) {
    __close(log.context);
    log.context.filePath = null;
  }
}

/**
 * get last error
 * @returns {string}
 */
function getLastError() {
  return lastError;
}

exports.create = create;
exports.close = close;
exports.getLastError = getLastError;